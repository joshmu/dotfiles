#!/usr/bin/env bun
// tmux-fzf-sessions - fzf session picker with zoxide integration
// Enter: switch to session/create from directory
// Ctrl+K: kill selected session (safely switches away first if current)

import { $ } from "bun";

// Colors
const GREEN = "\x1b[32m";
const YELLOW = "\x1b[33m";
const BLUE = "\x1b[34m";
const MAGENTA = "\x1b[35m";
const RESET = "\x1b[0m";

const stripAnsi = (str: string) => str.replace(/\x1b\[[0-9;]*m/g, "");
const cleanSessionName = (name: string) => name.replace(/ 󰄬$/, "").replace(/ 󰚩( 󰚩)*$/, "");

const currentSession = async () => {
  try {
    const result = await $`tmux display-message -p '#S'`.quiet().text();
    return result.trim();
  } catch {
    return "";
  }
};

const run = async (cmd: string[]) => {
  try {
    const proc = Bun.spawn(cmd, { stdout: "pipe", stderr: "pipe" });
    const text = await new Response(proc.stdout).text();
    return text.trim();
  } catch {
    return "";
  }
};

const parseSessionsByActivity = (data: string) =>
  data
    .split("\n")
    .filter(Boolean)
    .sort((a, b) => parseInt(b.split(":")[0]) - parseInt(a.split(":")[0]))
    .map((line) => line.split(":")[1]);

// Handle --kill flag
if (process.argv[2] === "--kill" && process.argv[3]) {
  const target = cleanSessionName(stripAnsi(process.argv[3]));
  const current = await currentSession();

  if (target === current) {
    const sessionsData = await run(["tmux", "list-sessions", "-F", "#{session_activity}:#{session_name}"]);
    const other = parseSessionsByActivity(sessionsData).find((s) => s !== current);
    if (other) {
      await $`tmux switch-client -t ${other}`.quiet();
      await $`tmux kill-session -t ${target}`.quiet();
    }
  } else {
    await $`tmux kill-session -t ${target}`.quiet();
  }
  process.exit(0);
}

// Fetch all data in parallel
const [paneData, claudePids, allProcs, sessionsData, zoxideData, current] = await Promise.all([
  run(["tmux", "list-panes", "-a", "-F", "#{session_name}:#{pane_pid}"]),
  run(["pgrep", "-x", "claude"]),
  run(["ps", "-A", "-o", "pid=,ppid="]), // All process parents in one call
  run(["tmux", "list-sessions", "-F", "#{session_activity}:#{session_name}"]),
  run(["zoxide", "query", "-l"]),
  currentSession(),
]);

// Build pane_pid -> session map
const paneToSession = new Map<string, string>();
for (const line of paneData.split("\n")) {
  const [session, pid] = line.split(":");
  if (session && pid) paneToSession.set(pid, session);
}

// Build pid -> ppid map (in-memory tree walking, no subprocess calls)
const pidToParent = new Map<string, string>();
for (const line of allProcs.split("\n")) {
  const [pid, ppid] = line.trim().split(/\s+/);
  if (pid && ppid) pidToParent.set(pid, ppid);
}

// Find Claude processes and count per session (in-memory, no subprocess calls)
const claudeSessions = new Map<string, number>();
const MAX_PARENT_DEPTH = 5;

for (const cpid of claudePids.split("\n")) {
  if (!cpid || !/^\d+$/.test(cpid)) continue;

  let ppid = cpid;
  for (let i = 0; i < MAX_PARENT_DEPTH; i++) {
    ppid = pidToParent.get(ppid) || "";
    if (!ppid || ppid === "1") break;

    const session = paneToSession.get(ppid);
    if (session) {
      claudeSessions.set(session, (claudeSessions.get(session) || 0) + 1);
      break;
    }
  }
}

// Build session list
const sessions = parseSessionsByActivity(sessionsData).map((name) => {
  const claudeCount = claudeSessions.get(name) || 0;
  const claudeIndicator = claudeCount > 0 ? ` ${MAGENTA}${"󰚩 ".repeat(claudeCount).trim()}${RESET}` : "";
  const isCurrent = name === current;
  const color = isCurrent ? YELLOW : GREEN;
  const marker = isCurrent ? " 󰄬" : "";
  return `${color}${name}${claudeIndicator}${marker}${RESET}`;
});

// Build zoxide list (already fetched in parallel)
const directories = zoxideData
  .split("\n")
  .filter(Boolean)
  .slice(0, 20)
  .map((dir) => `${BLUE}${dir}${RESET}`);

// Combine and run fzf
const combined = [...sessions, ...directories].join("\n");

const fzf = Bun.spawn(
  [
    "fzf",
    "--ansi",
    "--reverse",
    "--disabled",
    "--header",
    "(╯°□°)╯︵ ┻━┻",
    "--header-first",
    "--bind",
    "j:down,k:up",
    "--bind",
    "/:enable-search",
    "--bind",
    "ctrl-o:accept",
    "--preview-window=right:60%",
    "--preview",
    `item=$(echo {} | sed "s/\\x1b\\[[0-9;]*m//g"); if [[ "$item" != /* ]]; then name=$(echo "$item" | sed "s/ 󰚩.*$//" | sed "s/ 󰄬//"); printf "\\e[38;5;245m"; tmux capture-pane -pt "$name" -p 2>/dev/null | tail -40; printf "\\e[0m" || echo "No preview"; else printf "\\e[38;5;245m"; ls -la "$item" 2>/dev/null; printf "\\e[0m" || echo "Directory"; fi`,
    "--expect=ctrl-k,ctrl-o,enter",
  ],
  {
    stdin: "pipe",
    stdout: "pipe",
    stderr: "inherit",
  }
);

fzf.stdin.write(combined);
fzf.stdin.end();

const result = await new Response(fzf.stdout).text();
const lines = result.trim().split("\n");
const key = lines[0];
const selected = stripAnsi(lines.slice(1).join("\n"));

if (!selected) process.exit(0);

const isSession = !selected.startsWith("/");

// Ctrl+K: kill session
if (key === "ctrl-k" && isSession) {
  await $`${process.argv[1]} --kill ${selected}`.quiet();
  process.exit(0);
}

// Enter: switch or create
if (isSession) {
  await $`tmux switch-client -t ${cleanSessionName(selected)}`.quiet();
  process.exit(0);
}

// Directory selected - create/switch to session
const selectedName = selected.split("/").pop()?.replace(/\./g, "_") || "session";
const tmuxActive = process.env.TMUX || (await run(["pgrep", "tmux"]));

if (!tmuxActive) {
  await $`tmux new-session -s ${selectedName} -c ${selected}`.quiet();
  process.exit(0);
}

const sessionExists = (await $`tmux has-session -t ${selectedName}`.quiet().nothrow()).exitCode === 0;
if (!sessionExists) {
  await $`tmux new-session -ds ${selectedName} -c ${selected}`.quiet();
}

await $`tmux switch-client -t ${selectedName}`.quiet();
